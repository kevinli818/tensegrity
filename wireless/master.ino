#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
#include <tensegrity_wireless.h>

#define CE_PIN 9
#define CSN_PIN 10
#define ECHO_FREQUENCY 10000
#define ECHO_DEADLINE 1000

RF24 radio(CE_PIN, CSN_PIN);

uint64_t addresses[6] = {0xF0F0F0F000, 0xF0F0F0F011, 0xF0F0F0F022, 
                         0xF0F0F0F033, 0xF0F0F0F044, 0xF0F0F0F055};

//id is 0 for the master controller. 1 through 5 for the slaves.
int id = 0;

typedef struct
{
  bool has_responded; //true if controller has responded to latest EchoRequest
} controller;

//the perceived statuses of controllers 0 through 5. Note that status[0] is more 
//or less unused as there's no use for the master to track connectivity with itself.
controller controllers[6];

//system clock time to send next keepalive message.
uint64_t next_echo = 0;
//system clock time to verify that echos have been responded to.
uint64_t echo_deadline = 0xFFFFFFFF;
bool echo_verified = true;
//number generated by the system clock used to verify an EchoResponse
uint32_t verification_number;

//helper functions used in loop()
void send_echoes(void);
bool check_connections(void);
void handle_echo(uint8_t);

void setup() {
  Serial.begin(57600); //initialize serial connection for debugging purposes.
  radio.begin();

  //initialize controller array
  for (int i = 1; i <= 5; i++) {
    controllers[i].has_responded = false;
  }

  radio.openWritingPipe(addresses[0]);
  radio.openReadingPipe(1, addresses[1]);
  radio.openReadingPipe(2, addresses[1]);
  radio.openReadingPipe(3, addresses[1]);
  radio.openReadingPipe(4, addresses[1]);
  radio.openReadingPipe(5, addresses[1]);

  //radio.setPayloadSize(255);
  next_echo = millis() + 500;
  radio.startListening();
}

void loop() {
  //send echoes and set response deadline.
  if (millis() >= next_echo) {
    for (int i = 1; i <= 5; i++) {
      controllers[i].has_responded = false;
    }
    send_echoes();
    echo_deadline = millis() + ECHO_DEADLINE;
    echo_verified = false;
    next_echo = millis() + ECHO_FREQUENCY;
  }

  //checks to see if every controller has responded
  //to echo by the keepalive deadline.
  if (millis() >= echo_deadline && !echo_verified) {
    bool all_connected = check_connections();
    if (all_connected) {
      Serial.println("All controllers connected!");
    }
    echo_verified = true;
  }

  if (radio.available())
  {
    uint8_t m_id;
    uint8_t c_id;
    radio.read(&m_id, sizeof(char));
    while (!radio.available()) {;}
    radio.read(&c_id, sizeof(char)); 
    switch (m_id) {
      case ECHO:
        handle_echo(c_id);
        break;
    }
  }
}

//sends an echo request to all slave controllers
void send_echoes() {
  Serial.println("Sending echo requests.");
  Echo *e = (Echo *) malloc(ECHO_LENGTH);
  verification_number = (uint32_t) millis();
  e->verification_number = verification_number;
  Message *m = marshall_echo(0, e);
  e = unmarshall_echo(m->payload);
  radio.stopListening();
  radio.write(&m->message_id, sizeof(uint8_t));
  radio.write(&m->controller_id, sizeof(uint8_t));
  radio.write(m->payload, ECHO_LENGTH);
  radio.startListening();
  free(e);
  free(m);
}

//verifies that each slave controller has responded
//to the sent echo request.
bool check_connections() {
  bool all_connected = true;
  for (int i = 1; i <= 5; i++) {
    if (!controllers[i].has_responded) {
      Serial.print("Controller ");
      Serial.print(i);
      Serial.println(" not connected.");
      all_connected = false;
    }
  }
  return all_connected;
}

//updates the status of the controller an EchoResponse was received from
void handle_echo(uint8_t c_id) {
  void *payload = malloc(ECHO_LENGTH);
  while (!radio.available()) {;}
  radio.read(payload, ECHO_LENGTH);
  Echo *e = unmarshall_echo(payload);
  if (e->verification_number == verification_number) {
    Serial.print("Received echo response from controller ");
    Serial.print(c_id);
    Serial.println(" .");
    controllers[c_id].has_responded = true;
  }
  free(payload);
  free(e);
}
